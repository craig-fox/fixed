'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _types = require('./types');

var _types2 = _interopRequireDefault(_types);

var _traverseSchema = require('./traverse-schema');

var _traverseSchema2 = _interopRequireDefault(_traverseSchema);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function assignValue(result, segments, value) {
  var firstSegment = segments[0];

  if (segments.length === 1) {
    result[firstSegment] = value;
    return;
  }

  var nextResult = result[firstSegment];
  if (!nextResult) {
    nextResult = result[firstSegment] = {};
  }

  assignValue(nextResult, segments.slice(1), value);
}

function throwIfStrict(options) {
  if (options.strict) {
    throw new Error('Incorrect type');
  }
}

function processPrimitiveType(raw, type, options) {
  var value = raw;

  switch (type) {
    case _types2.default.string:
      {
        if (typeof raw !== 'string') {
          throwIfStrict(options);

          value = '' + raw;
        }

        break;
      }
    case _types2.default.boolean:
      {
        if (typeof raw !== 'boolean') {
          throwIfStrict(options);

          value = raw === 'true';
        }
        break;
      }
    case _types2.default.integer:
      {
        if (typeof raw !== 'number') {
          throwIfStrict(options);

          value = parseInt(raw, 10);

          if (isNaN(value)) {
            throw new Error('Couldn\'t parse integer');
          }
        }
        break;
      }
    case _types2.default.float:
      {
        if (typeof setting !== 'number') {
          throwIfStrict(options);

          value = parseFloat(raw);
        }

        if (isNaN(value)) {
          throw new Error('Couldn\'t parse float');
        }
        break;
      }
    case _types2.default.date:
      {
        if (!(raw instanceof Date)) {
          throwIfStrict(options);

          value = new Date(raw);
        }

        if (value.toString() === 'Invalid Date') {
          throw new Error('Couldn\'t parse date');
        }
        break;
      }
    case _types2.default.array:
      {
        if (!(raw instanceof Array)) {
          throwIfStrict(options);

          value = raw;
        }

        break;
      }

    default:
      {
        throw new Error('Not supported type');
      }
  }

  return value;
}

function buildConfig(schema, getValue, options) {
  var result = {};

  (0, _traverseSchema2.default)(schema, function (descriptor, segments) {
    var raw = getValue(segments, descriptor);
    var value = raw;

    if (descriptor.type instanceof Array) {
      (function () {
        if (!(raw instanceof Array)) {
          throwIfStrict(options);

          value = [raw];
        }

        var underlyingType = descriptor.type[0];

        value = value.map(function (x) {
          return processPrimitiveType(x, underlyingType, options);
        });
      })();
    } else {
      value = processPrimitiveType(value, descriptor.type, options);
    }
    assignValue(result, segments, value);
  });

  return result;
}

exports.default = buildConfig;